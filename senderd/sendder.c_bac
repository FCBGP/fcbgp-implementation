#include <stdio.h>
#include <string.h>
#include <net/if.h>
#include <linux/if_ether.h>
#include <time.h>
#include <curl/curl.h>
#include <errno.h>
#include <endian.h>

#include "libnio.h"
#include "libdiag.h"
#include "libcrc32.h"
#include "libsysmgr.h"
#include "libmutex.h"
#include "libdhcpv6.h"
#include "ip6.h"
#include "cJSON.h"
#include "p4.h"
#include "pkt6.h"

#define NIO_SCANNER_LENGTH 2500
#define PROTO_IP 0x0800
#define PROTO_arp 0x0806                    //current not used
#define PROTO_IPV6 0x86dd                 // current not used

#define LINK_ADDR "fe80::2ad2:44ff:fe03:f6fb"
#define LOCAL_IPV6 "2402:f000:6:1c09::28:25"
#define REMOTE_IPV6 "2402:f000:6:1c09::28:25"

#define WEB_IP "127.0.0.1"
#define WEB_PORT 80
#define URI "/test/save"
#define URL "127.0.0.1:80/test/save"

#define EPV_DATAHASH(p4_header) (p4_header)
#define EPV_SID(p4_header) (p4_header+16)
#define EPV_LASTIP(p4_header) (p4_header+32)
#define EPV_NEXTIP(p4_header) (p4_header+36)
#define EPV_MAC1(p4_header) (p4_header+40)
#define EPV_MAC2(p4_header) (p4_header+44)
#define OPT_TS(p4_header) (p4_header+48)
#define OPT_SID(p4_header, i) (p4_header+52+(i)*16)
#define OPT_TIME_USED(p4_header, i) (p4_header+64+(i)*16)
#define RFL_MAC(p4_header, i) (p4_header+16+i*4)

nio_ctx_t *g_scanner_nio = NULL;

uint8_t g_scanner_smac[6] = {0};
uint8_t g_scanner_dmac[6] = {0xcc,0xb0,0xda,0xa5,0x2c,0xF5};
uint8_t g_scanner_sip6[64] = {0};
uint8_t g_scanner_dip6[64] = {0};

cJSON *g_cJSON_start = NULL;
cJSON *g_cJSON_eth = NULL;
cJSON *g_cJSON_ipv6 = NULL;
cJSON *g_cJSON_udp = NULL;
cJSON *g_cJSON_p4 = NULL;
char *g_payload = NULL;
int g_pkt_count = 0;
int g_pkt_type = 0;

unsigned short my_checksum(unsigned char *addr, int len){
    int nleft=len;
    int sum=0;
    unsigned char * w=addr;
    unsigned short answer=0;

    while (nleft>1)
    {
        sum+=*w << 8 | *(w+1);
        w += 2;
        nleft-=2;
    }

    if (nleft==1)
    {
        *(unsigned char *)(&answer)=*(unsigned char *)w;
        sum+=answer;
    }

    sum=(sum>>16)+(sum & 0xffff);
    sum+=(sum>>16);
    answer=~sum;
    return(answer);
}

static uint32_t get_pkt_hash(char *p4)
{
    //get datahash 31-63
    uint32_t res = 0;
    res = *((uint32_t *)EPV_DATAHASH(p4)+2);
    reverse_uint32(&res);
    return res;
}

static int get_pkt_indi(char *p4, char *res)
{
    uint32_t *indi;
    int ret = 0;
    indi = (uint32_t *)EPV_DATAHASH(p4);
    *indi = (*indi & 0xff000000) + 0x03000a;
    ret = inet_ntop(AF_INET, indi, res, 64);

    return 0;
}


static int get_indi_key_str(char *p4, char *res)
{
    uint32_t indi = 0;
    indi = *((uint32_t *)EPV_DATAHASH(p4));

    indi = (indi & 0xff000000) + 0x03000a;
    get_keystr_by_indi(indi, res);
    //    reverse_uint32(&res);


    return 0;
}

static uint32_t get_indi_key(char *p4)
{
    //get datahash 95-127 as indi address
    //get key by address
    uint32_t res = 0;
    uint32_t indi = 0;

    indi = *((uint32_t *)EPV_DATAHASH(p4));
    indi = (indi & 0xff000000) + 0x03000a;

    res = get_key_by_indi(indi);
    //    reverse_uint32(&res);

    return res;
}

static uint32_t get_pkt_mac(char *p4)
{
    return *((uint32_t *)EPV_MAC1(p4));
}

int curl_process_get(char *url)
{
    struct curl_slist* headers = NULL;

    curl_global_init(CURL_GLOBAL_ALL);
    CURL *easy_handle = curl_easy_init();

    curl_easy_setopt(easy_handle, CURLOPT_URL, url);

    curl_easy_perform(easy_handle);

    curl_easy_cleanup(easy_handle);
    curl_global_cleanup();

    return 0;
}

int curl_process_post(char *url, char *data, int size)
{
    struct curl_slist* headers = NULL;
    FILE *fp = NULL;
    fp = fopen("/dev/null", "wr");

    curl_global_init(CURL_GLOBAL_ALL);
    CURL *easy_handle = curl_easy_init();

    curl_easy_setopt(easy_handle, CURLOPT_URL, url);
    curl_easy_setopt(easy_handle, CURLOPT_WRITEDATA, fp);
    // 单个域post
    curl_easy_setopt(easy_handle, CURLOPT_POSTFIELDS, data);

    headers = curl_slist_append(headers, "Content-Type:application/json;charset=UTF-8");
    curl_easy_setopt(easy_handle, CURLOPT_HTTPHEADER, headers);
    curl_easy_setopt(easy_handle, CURLOPT_POST, 1);

    curl_easy_perform(easy_handle);

    curl_easy_cleanup(easy_handle);
    curl_global_cleanup();

    return 0;
}

char char_to_hex(char c)
{
    char ret;
    if (c >= '0' && c <= '9') {
        ret = c - '0';
    } else if (c >= 'a' && c <= 'f') {
        ret = c-'a'+10;
    } else if (c >= 'A' && c <= 'F') {
        ret = c-'A'+10;
    } else {
        ret = -1;
    }

    return ret;
}

int post_message(char *data)
{
    int ret = 0;

    char msg[1024] = {0};
    memset(msg, 0, sizeof(msg));

    snprintf(msg, sizeof(msg), "{\"data\":\"%s\"}", data);
    //   printf("msg is %s.\n", msg);
    char url[] = "localhost:80/test/update/status";

    ret = curl_process_post(url, msg, strlen(msg)+1);

    return ret;
}

int scanner_process_ipv6(nio_ctx_t *ctx, nio_pkt_t * pkt)
{
    int i=0;
    int ret;
    uint32_t used = 0;
    uint32_t indi_key = 0;
    uint32_t pkt_mac = 0;
    uint32_t crc32_data = 0;
    uint32_t crc_res = 0;
    uint32_t opvi = 0;
    uint32_t host_mac = 0;
    int len = 0;
    cJSON *tmp = NULL;
    cJSON *keys = NULL;
    cJSON *hosts = NULL;
    cJSON *macs = NULL;

    char *key_str = NULL;
    char *host_str = NULL;
    char *mac_str = NULL;
    char *reporter = NULL;
    char *wrong = NULL;
    uint8_t hash_res[16] = {0};
    uint32_t key = 0;

    char web_msg[1024] = {0};

    struct ip6_hdr *ip6h = pkt->data + ETH_HDRLEN;
    char *p4_header = pkt->data + ETH_HDRLEN + IP6_HDRLEN;

    uint32_t rfl_dst = 0;
    uint32_t src_mac = 0;
    char rfl_dst_str[64] = {0};
    char src_mac_str[64] = {0};

    char ip_src[64] = {0};
    char ip_dst[64] = {0};
    ret = inet_ntop(AF_INET6, &ip6h->ip6_src, ip_src, 64);
    ret = inet_ntop(AF_INET6, &ip6h->ip6_dst, ip_dst, 64);

    int time_used[5] = {0, 0, 0, 0, 0};
    int total = 0;

    char indi[64] = {0};
    get_pkt_indi(p4_header, indi);

    parse_config(CONFIG_FILE);
    printf("\n");

    printf("\033[1m\033[42m------------ S T A R T ------------\033[0m\n");
    //   printf("\033[1m---------- M A C ----------\033[0m");
    //   print_pkt(pkt->data, pkt->data+ETH_HDRLEN);
    //   printf("\033[1m---------- I P ----------\033[0m");
    //   print_pkt(ip6h, pkt->data+ETH_HDRLEN+IP6_HDRLEN);
    printf("\033[1m---------- P 4 ----------\033[0m");
    print_pkt(p4_header, pkt->data+pkt->length);
    printf("\033[1m\033[42m------------ E N D ------------\033[0m\n");

    keys = (tmp = cJSON_GetObjectItem(g_cJSON_p4, "keys"));
    hosts = (tmp = cJSON_GetObjectItem(g_cJSON_p4, "hosts"));
    macs = (tmp = cJSON_GetObjectItem(g_cJSON_p4, "host_mac"));

    g_pkt_count++;
    unsigned char tc = be32toh(ip6h->ip6_ctlun.ip6_un1.ip6_un1_flow)>>20 & 0xff;

    switch (ip6h->ip6_nxt) {
    case 143:
        if(g_pkt_type != 143) {
            g_pkt_type = 143;
            g_pkt_count = 0;
        }
        used = get_pkt_hash(p4_header);
        indi_key = get_indi_key(p4_header);
        pkt_mac = get_pkt_mac(p4_header);
        crc32_data = used + indi_key;
        reverse_uint32(&crc32_data);
        crc_res = crc32_run(0, (char*)&crc32_data, 4);
        reverse_uint32(&crc_res);
        if (crc_res == pkt_mac) {

            snprintf(web_msg, sizeof(web_msg), "{\"yuanIp\":\"\", \"mudiIp\":\"\", \"jubaoIp\":\"\", \"cuowuIp\":\"\", \"nodeIp\":\"%s\"}", indi);
            //            printf("web_msg is %s.\n", web_msg);
            ret = curl_process_post(URL, web_msg, strlen(web_msg)+1);
        } else {
            printf("epv wrong.\n");
        }
        if(g_pkt_count++ > 40){
            if(tc == 12) {
                post_message("The actual path is 'source-A-C-E-B-destination,the anticipate path is A-C-D-E-B, Wrong!'");
            }

            else if(tc == 0){
                post_message("The actual path is 'source-A-C-D-E-B-destination'");
            }
            g_pkt_count=0;
        }

        for(i=0; i<5; i++) {
            time_used[i] = *(uint32_t *)OPT_TIME_USED(p4_header, i);
            reverse_uint32(time_used+i);
            total += time_used[i];
        }
        if (tc == 199) {
            g_pkt_count = 40;
            if(g_pkt_count++ >= 40){
                sprintf(web_msg, "A:%dns; C:%dns; D:%dns; E:%dns; B:%dns. -----total: %dns", time_used[0], time_used[1],time_used[2],time_used[3],time_used[4], total);
                printf("web_msg is %s.\n", web_msg);
                post_message(web_msg);
                g_pkt_count=0;
            }
        }

        break;
    case 144:
        if(g_pkt_type != 144) {
            g_pkt_type = 144;
            g_pkt_count = 0;
        }
        used = get_pkt_hash(p4_header);
        len = cJSON_GetArraySize(keys);

        for(i=0; i<5; i++){
            uint  j=i;
            if((tc == 22) && (i==2))    continue;
            key_str = (tmp = cJSON_GetArrayItem(keys, i)) ? tmp->valuestring : "0";
            host_str = (tmp = cJSON_GetArrayItem(hosts, i)) ? tmp->valuestring : "0";
            key = atoi(key_str);
            crc32_data = key + used;
            reverse_uint32(&crc32_data);
            crc_res = crc32_run(0, (char*)&crc32_data, 4);
            if((tc == 22) &&(i>2))  j=i-1;
            pkt_mac = *((uint32_t *)RFL_MAC(p4_header, j));
            reverse_uint32(&pkt_mac);
            if (crc_res == pkt_mac) {
                snprintf(web_msg, sizeof(web_msg), "{\"yuanIp\":\"\", \"mudiIp\":\"\", \"jubaoIp\":\"\", \"cuowuIp\":\"\", \"nodeIp\":\"%s\"}", host_str);
                //               printf("web_msg is %s.\n", web_msg);
                ret = curl_process_post(URL, web_msg, strlen(web_msg)+1);
            } else {
                //snprintf(web_msg, sizeof(web_msg), "{\"yuanIp\":\"\", \"mudiIp\":\"\", \"jubaoIp\":\"\", \"cuowuIp\":\"\", \"nodeIp\":\"%s\"}", host_str);
                snprintf(web_msg, sizeof(web_msg), "{\"yuanIp\":\"%s\", \"mudiIp\":\"%s\", \"jubaoIp\":\"\", \"cuowuIp\":\"%s\", \"nodeIp\":\"\"}", ip_src, ip_dst, host_str);
                //                printf("web_msg_ is %s.\n", web_msg);
                ret = curl_process_post(URL, web_msg, strlen(web_msg)+1);
            }
        }
        if(g_pkt_count++ > 40){
            if(tc == 22) {
                post_message("The actual path is 'source-A-C-E-B-destination'");
            }
            else if (tc == 0){
                post_message("The actual path is 'source-A-C-D-E-B-destination'");
            }
            g_pkt_count = 0;

        }
        break;
    case 145:
        if(g_pkt_type != 145) {
            g_pkt_type = 145;
            g_pkt_count = 0;
        }
        used = get_pkt_hash(p4_header);
        len = cJSON_GetArraySize(keys);

        for(i=0; i<5; i++) {
            key_str = (tmp = cJSON_GetArrayItem(keys, i)) ? tmp->valuestring : "0";
            host_str = (tmp = cJSON_GetArrayItem(hosts, i)) ? tmp->valuestring : "0";
            ret = strmd5digest(key_str, hash_res);
            opvi = *((uint32_t *)hash_res);
            reverse_uint32(&opvi);
            //            printf("opvi %x.\n", opvi);
            key = atoi(key_str);

            crc32_data = opvi + key + used;
            //            printf("opvi is %x key ix %x used is %x.\n", opvi, key, used);
            //            printf("crc32 uis %x.\n", crc32_data);
            reverse_uint32(&crc32_data);
            crc_res = crc32_run(0, (char*)&crc32_data, 4);
            pkt_mac = *((uint32_t*)OPT_SID(p4_header, i));
            reverse_uint32(&pkt_mac);
            if (crc_res == pkt_mac) {
                snprintf(web_msg, sizeof(web_msg), "{\"yuanIp\":\"\", \"mudiIp\":\"\",\
                        \"jubaoIp\":\"\", \"cuowuIp\":\"\", \"nodeIp\":\"%s\"}", host_str);
                //                printf("web_msg is %s.\n", web_msg);
                ret = curl_process_post(URL, web_msg, strlen(web_msg)+1);
            } else {
                snprintf(web_msg, sizeof(web_msg), "{\"yuanIp\":\"\", \"mudiIp\":\"\",\
                        \"jubaoIp\":\"\", \"cuowuIp\":\"\", \"nodeIp\":\"%s\"}", host_str);
                ret = curl_process_post(URL, web_msg, strlen(web_msg)+1);
            }

            time_used[i] = *(uint32_t *)OPT_TIME_USED(p4_header, i);
            reverse_uint32(time_used+i);
            total += time_used[i];
        }
        if (tc == 199) {
            g_pkt_count = 40;
            if(g_pkt_count++ >= 40){
                sprintf(web_msg, "A:%dns; C:%dns; D:%dns; E:%dns; B:%dns. -----total: %dns", time_used[0], time_used[1],time_used[2],time_used[3],time_used[4], total);
                post_message(web_msg);
                g_pkt_count=0;
            }
        }
        //       printf("A: %dns\nC: %dns;\nD: %dns;\nE: %dns;\nB: %dns\n", time_used[0], time_used[1],time_used[2],time_used[3],time_used[4]);
        //       printf("total used %dns.\n", total);
        if((g_pkt_count++ > 40) && (tc != 199)){
            post_message("The actual path is 'source-A-C-D-E-B-destination'");
            g_pkt_count=0;
        }

        break;
    case 188:
        //        printf("received 188 packet.\n");
        rfl_dst = *(uint32_t *)EPV_MAC1(p4_header);
        ret = inet_ntop(AF_INET, &rfl_dst, rfl_dst_str, 64);
        src_mac = *(uint32_t *)EPV_NEXTIP(p4_header);
        snprintf(src_mac_str, 63, "%x", src_mac);
        //        printf("%s.\n", src_mac_str);
        for(i=1; i<5; i++) {
            mac_str = (tmp = cJSON_GetArrayItem(macs, i)) ? tmp->valuestring : "0";
            if(!strcmp(src_mac_str, mac_str)) {
                reporter = (tmp = cJSON_GetArrayItem(hosts, i)) ? tmp->valuestring : "0";
                wrong = (tmp = cJSON_GetArrayItem(hosts, i-1)) ? tmp->valuestring : "0";
            }
        }
        snprintf(web_msg, sizeof(web_msg), "{\"yuanIp\":\"%s\", \"mudiIp\":\"%s\", \"jubaoIp\":\"%s\", \"cuowuIp\":\"%s\", \"nodeIp\":\"\"}", \
                ip_src, "a00:30c::1000", reporter, wrong);
        printf("web_msg is %s.\n", web_msg);
        ret = curl_process_post(URL, web_msg, strlen(web_msg)+1);
        break;
    case 200:
        reporter = (tmp = cJSON_GetArrayItem(hosts, 4)) ? tmp->valuestring : "0";
        wrong = (tmp = cJSON_GetArrayItem(hosts, 2)) ? tmp->valuestring : "0";
        snprintf(web_msg, sizeof(web_msg), "{\"yuanIp\":\"%s\", \"mudiIp\":\"%s\", \"jubaoIp\":\"%s\", \"cuowuIp\":\"%s\", \"nodeIp\":\"\"}", ip_src, "a00:30c::1000", reporter, wrong);
        printf("web_msg is %s.\n", web_msg);
        ret = curl_process_post(URL, web_msg, strlen(web_msg)+1);
        break;
    case 201:
        reporter = (tmp = cJSON_GetArrayItem(hosts, 3)) ? tmp->valuestring : "0";
        wrong = (tmp = cJSON_GetArrayItem(hosts,1)) ? tmp->valuestring : "0";
        snprintf(web_msg, sizeof(web_msg), "{\"yuanIp\":\"%s\", \"mudiIp\":\"%s\", \"jubaoIp\":\"%s\", \"cuowuIp\":\"%s\", \"nodeIp\":\"\"}", ip_src, "a00:30c::1000", reporter, wrong);
        printf("web_msg is %s.\n", web_msg);
        ret = curl_process_post(URL, web_msg, strlen(web_msg)+1);
        break;


    default:
        break;
    }

    return 0;
}

int scanner_link_init(char *ifname)
{
    int ret;

    if (ifname == NULL) {
        DIAG_ERROR("invalid if name!\n");
        return -EINVAL;
    }

    if (g_scanner_nio!= NULL) {
        DIAG_ERROR("cfg nio exists!\n");
        return -EINVAL;
    }

    ret = sys_netif_ethaddr_get(ifname, g_scanner_smac);
    if (ret < 0) {
        DIAG_ERROR("get scanner interface %s ethaddr failed\n", ifname);
        return ret;
    }

    g_scanner_nio = nio_create(ifname, g_scanner_smac, g_scanner_dmac, &g_raw_sock_ops);
    if (g_scanner_nio == NULL) {
        DIAG_ERROR("create scanner nio failed\n");
        return -ENOMEM;
    }

    int argc = 8;
    int proto = ETH_P_ALL;

    int argv[] = {proto, 2, 0x400000, 0x400000, 3000, 1, 0, 0};
    ret = nio_open(g_scanner_nio, argc, argv);
    if (ret < 0) {
        DIAG_ERROR("open scanner nio failed\n");
        nio_close(g_scanner_nio);
        g_scanner_nio = NULL;
        return ret;
    }

    ret = nio_add_ptype(g_scanner_nio, 0x86dd, scanner_process_ipv6);
    if (ret < 0) {
        DIAG_ERROR("add scanner nio handler failed\n");
        nio_close(g_scanner_nio);
        g_scanner_nio = NULL;
        return ret;
    }

    ret = nio_start(g_scanner_nio);
    if (ret < 0) {
        DIAG_ERROR("start scanner nio failed\n");
        nio_close(g_scanner_nio);
        g_scanner_nio = NULL;
        return ret;
    }

    return 0;
}

int scanner_link_fini(void)
{
    if (g_scanner_nio) {
        nio_stop(g_scanner_nio);
        nio_close(g_scanner_nio);
        g_scanner_nio = NULL;
    }
    return 0;
}

int parse_config(char *fname)
{
    mbs_t mbs = NULL;
    mbs_t data = NULL;

    FILE *fp = NULL;
    fp = fopen(fname, "r");
    if (fp == NULL) {
        return -ENOENT;
    }

    while (1) {
        mbs = mbsreadline(fp);
        if (mbs == NULL) {
            break;
        }

        mbscatmbs(&data, mbs);
        mbsfree(mbs);
    }

    fclose(fp);

    cJSON * tmp;

    g_cJSON_start = cJSON_Parse(data);
    if (g_cJSON_start == NULL) {
        DIAG_ERROR("p4 parse json failed.\n");
        return -1;
    }

    g_cJSON_eth = cJSON_GetObjectItem(g_cJSON_start, "eth");
    g_cJSON_ipv6 = cJSON_GetObjectItem(g_cJSON_start, "ipv6");
    g_cJSON_udp = cJSON_GetObjectItem(g_cJSON_start, "udp");
    g_cJSON_p4 = cJSON_GetObjectItem(g_cJSON_start, "p4");
    g_payload = (tmp = cJSON_GetObjectItem(g_cJSON_start, "payload")) ? tmp->valuestring : "123456789";

    mbsfree(data);

    return 0;
}

int mysender_send_p4_pkt(char *p4_pkt, unsigned int p4_len)
{
    int ret;
    int i;
    nio_pkt_t pkt;
    memset (&pkt, 0, sizeof(nio_pkt_t));

    pkt.data = (uint8_t *)p4_pkt;
    pkt.length = p4_len;

    ret = nio_forward(g_scanner_nio, 0, &pkt);
    if (ret < 0) {
        DIAG_ERROR("send hex failed.\n");
        return ret;
    }

    return 0;
}

int mysender_send_hex(char *hex)
{
    int ret;
    int i;
    nio_pkt_t pkt;
    memset (&pkt, 0, sizeof(nio_pkt_t));

    char *buffer = NULL;
    buffer = malloc(NIO_SCANNER_LENGTH + 8);
    if (buffer == NULL) {
        return -ENOMEM;
    }
    memset(buffer, 0, NIO_SCANNER_LENGTH + 8);

    pkt.data = (uint8_t *)buffer;
    for (i=0; i<strlen(hex); i+=2) {
        *(buffer++) = char_to_hex(hex[i]) << 4 | char_to_hex(hex[i+1]);
        pkt.length++;
    }

    ret = nio_forward(g_scanner_nio, 0, &pkt);
    if (ret < 0) {
        DIAG_ERROR("send hex failed.\n");
        return ret;
    }

    buffer = NULL;   //we should not use free, because it is freed in nio_forward function
    return 0;
}

int main(int argc, char *argv[])
{
    int i;
    int ret = 0;
    int verbose = 0;
    char dipaddr[32] = {0, };
    char sipaddr[32] = {0, };
    int count = 3;
    int port = 6666;
    char *ifname = NULL;
    char *hex = NULL;
    char smac[32] = {0, };
    char dhcp_test = 0;
    char loop = 0;
    int p4 = 0;

    diag_init("test_p4");

    ret = cache_init();
    if (ret < 0) {
        goto out;
    }

    ret = mbsinit(10, 10240, 4096, 4096, 512, 512, 256, 256, 64, 64, 16);
    if (ret < 0) {
        DIAG_ERROR("mbs init failed.\n");
        goto out;
    }

    srand((unsigned)time(NULL));

    for (i=0; i<argc; i++) {
        if (strcmp(argv[i], "-i") == 0) {
            ifname = argv[i + 1];
        } else if (strcmp(argv[i], "-v") == 0) {
            verbose = 1;
        } else if (strcmp(argv[i], "-p") == 0) {
            port = atoi(argv[i+1]);
        } else if (strcmp(argv[i], "-hex") == 0) {
            hex = argv[i+1];
        } else if (strcmp(argv[i], "loop") == 0) {
            loop = 1;
        } else if (strcmp(argv[i], "p4") == 0) {
            p4 = 1;
        } else if (strcmp(argv[i], "-h") == 0) {
            printf("%s -i <interface> { -syn <destip> | -hex <hexcode> | -dhcp <count> } -v | -h | -loop \n", argv[0]);
            return 0;
        }
    }

    if (ifname == NULL || !(strcmp(dipaddr, "") || hex != NULL || count != 0 || p4)) {
        DIAG_ERROR("(ip or hex) and ifname must be given.\n");
        printf("(ip or hex) and ifname must be given.\n");
        return -1;
    }

    ret = scanner_link_init(ifname);
    if (ret < 0) {
        DIAG_ERROR("scanner link %s init failed\n", ifname);
        return ret;
    }

    if (verbose) {
        nio_verbose(g_scanner_nio, 1);
    }

    if (p4) {
        char p4_pkt[4096] = {0};
        unsigned int p4_len = 4096;
        char *pp4_pkt = NULL;

        ret = parse_config(CONFIG_FILE);
        if (ret < 0) {
            printf("parse config file failed.\n");
            goto out;
        }

        while(count-- || loop) {
            ret = gen_p4_pkt(ifname, p4_pkt, &p4_len);
            if (ret < 0) {
                DIAG_ERROR("generate p4 package failed.\n");
                goto out;
            }

            pp4_pkt = malloc(4096);
            memcpy(pp4_pkt, p4_pkt, sizeof(p4_pkt));
            ret = mysender_send_p4_pkt(pp4_pkt, p4_len);
            if (ret < 0) {
                DIAG_ERROR("send p4 pkt failed.\n");
                goto out;
            }
            usleep(500000);
        }
    }

    if (hex != NULL) {
        while(1) {
            ret = mysender_send_hex(hex);
            if (ret < 0) {
                DIAG_ERROR("send hex failed.\n");
                goto out;
            }
            usleep(500000);
        }
    }

    while(1);
out:
    cJSON_Delete(g_cJSON_start);
    mbsfini();
    cache_fini();
    scanner_link_fini();
    nio_stop(g_scanner_nio);
    nio_close(g_scanner_nio);
    return ret;
}

